PI = 3.14159

map = { .0 = { .1 = { .100.54 = 1.12}, .2 = { .83.26 = -0.04}}, .1 = { .0 = { .100.54 = -2.02}, .2 = { .101.48 = -1.17}}, .2 = { .0 = { .83.26 = 3.10}, .1 = { .101.48 = 1.97}}}


#
# Find the distance between two angles
#
function delta_angle(angle_1, angle_2) {
	d = angle_1 - angle_2
	return math.abs((d + PI) % (2*PI) - PI)
}

#
# Get the confidence of a given measured angle vs a confidence angle
#
ALPHA = 10 # Steepness
BETA = PI/4 # 50% value: range from 0 to PI

function get_confidence(map_angle, measured_angle){
	delta = delta_angle(map_angle, measured_angle)
	confidence = 1/(1 + math.exp(ALPHA*(delta-BETA)))

	return confidence
}

# copying tables the right way
function table_copy(t) {
  var t2 = {}
  foreach(t, function(key, value) {
      t2[key] = value
    })
  return t2
}

function get_max_confidence(list_of_confidences){

	best_sum = 0

	foreach(list_of_confidences, function(index, r_c){

		c_sum = 0

		foreach(r_c, function(rid, confidence){
				
			c_sum = c_sum + confidence

		})

		if (c_sum > best_sum){
			
			best_sum = c_sum

		}

	})

	return best_sum

}

# Returns a table of indexes where there is no desired robot
function list_contains_robot(list, robot){

	retval = {}

	foreach(list, function(index, r_c){
	
		no_robot = 1

		foreach(r_c, function(rid, val){

			if(rid == robot) {
				no_robot = 0
			}

		})

		if(no_robot) {
			retval[index] = 1
		}

	})

	return retval

}

# Find the max confidence arrangement given the list of confidences, map_node is the node on the map the confidence is comparing to, r_c is a table containing the neighbors robot id and the confidence in the specific map node
function find_max_confidence(list_of_confidence){

	possible_c = {}
	index = 0

	foreach(list_of_confidence, function(map_node, r_c){

		foreach(r_c, function(rid, c_val){

			lcr = list_contains_robot(possible_c, rid)

			if(size(lcr)){

				foreach(lcr, function(index, one){

					possible_c[index][rid] = c_val

				})

			} else {

				c_list = {}			
				c_list[rid] = c_val	

				possible_c[index] = c_list
				index = index + 1

			}

		})

	})

	return get_max_confidence(possible_c)

}

#
# Function returns a confidence map
#
function get_confidence_map(){

	
	neighbors_poses = neighbors.poses

	# Evaluate the confidence of the robot for each point in the map normalized from [0, 1]
	foreach(map, function(point, map_edges){

		confidence_map = {}

		if(size(neighbors_poses) == 0){
			confidence_map[point] = 0
		} else {
			c_total = 0

			p_c = {} # Possible confidences {.Point = {.Neighbor_1 = c1, .Neighbor_2 = c2}}

			foreach(map_edges, function(m_neighbor, m_values){ 
				foreach(m_values, function(distance, angle){


					r_c = {} # List of confidences per neighbor robot

					foreach(neighbors_poses, function(r_neighbor, r_values){

						c = get_confidence(angle, r_values.azimuth + pose.orientation.yaw)

						r_c[r_neighbor] = c

					})

					p_c[m_neighbor] = r_c

					#c_total = c_total + c

				})
			})

			c_max = find_max_confidence(p_c)
			confidence_map[point] = c_max/size(map_edges)

		}

	})

	# Normalize total probabilities from 0 to 1
	total = 0
	foreach(confidence_map, function(point, value){
		total = total + value
	})

	if (total > 0){
		foreach(confidence_map, function(point, value){
			confidence_map[point] = value/total
		})
	}

	return confidence_map

}

function init() {
  reset()

}

function step() {

	confidence_map = get_confidence_map()

}




#
# Executed once upon resetting
#
function reset() {

}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

