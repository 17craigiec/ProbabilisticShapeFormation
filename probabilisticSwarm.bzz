PI = 3.14159

map = { .0 = { .1 = { .124.84 = 0.03}, .2 = { .156.87 = -0.74}, .3 = { .103.21 = -1.56}}, .1 = { .0 = { .124.84 = -3.12}, .2 = { .109.16 = -1.65}, .3 = { .162.79 = -2.43}}, .2 = { .0 = { .156.87 = 2.40}, .1 = { .109.16 = 1.49}, .3 = { .114.43 = 3.12}}, .3 = { .0 = { .103.21 = 1.59}, .1 = { .162.79 = 0.71}, .2 = { .114.43 = -0.02}}}

#
# Executed once at init time
#
function init() {
  reset()
	map_target_vectors = {}

	foreach(map, function(point, list){
		avg_ndistance = 0.0
		avg_nangle = 0.0 
		avg_nangle_sin = 0.0
		avg_nangle_cos = 0.0
		index = 0.0
		foreach(list, function(neighbor, innerTable) {
			index = index + 1.0
			foreach(innerTable, function(distance, angle){
			avg_ndistance = avg_ndistance + distance
			avg_nangle_sin = avg_nangle_sin + math.sin(angle)
			avg_nangle_cos = avg_nangle_cos + math.cos(angle)
			})
		})
		avg_ndistance = avg_ndistance/index
		avg_nangle_sin = avg_nangle_sin/index
		avg_nangle_cos = avg_nangle_cos/index

		avg_nangle = math.atan(avg_nangle_sin, avg_nangle_cos)
		map_target_vectors[point] = {.d = avg_ndistance, .a = avg_nangle}
	}) 

}

#
# Executed for each step
#
function step() {

	avg_distance = 0.0
	avg_anlge = 0.0
	avg_angle_sin = 0.0
	avg_angle_cos = 0.0
	i = 0.0
	neighbors.foreach(
  	function(rid, data) {
			 i = i + 1
       avg_distance = avg_distance + data.distance
			 avg_angle_sin = avg_angle_sin + math.sin(data.azimuth)
			 avg_angle_cos = avg_angle_cos + math.cos(data.azimuth)
 		})
	avg_distance = avg_distance/i
	avg_angle = math.atan(avg_angle_sin/i, avg_angle_cos/i)
	#foreach(confidence, function(key, value) {
				#avg_d = 0.0
				#avg_theta = 0.0
				#foreach(map[key],function(neighbor, table) {
				#	foreach(table,function(distance, angle) {
				#		log(distance, '->', angle)
				#		avg_d = avg_d + (distance*value)
				#		avg_theta = avg_theta + (angle*value)
				#	})	
				#})
    #})
debug.rays.add(255,0,0,0.0,0.0,0.1, avg_distance*math.cos(avg_angle)/100, avg_distance*math.sin(avg_angle)/100, 0.1 )


	avg_angle = avg_angle + pose.orientation.yaw
	current_vector = {.avg_distance = avg_angle}

	correction_vectors = {}	
	total_corection_distance = 0.0
	foreach(map_target_vectors,
  	function(rid, innnerTable) {
		total_corection_distance = 		total_corection_distance + (avg_distance - innnerTable.d)
		correction_vectors[rid] = {.a = (avg_angle-innnerTable.a), .d = (avg_distance - innnerTable.d)}})

	probability = {}
	foreach(correction_vectors,
  	function(id, table) {
		probability[id] = (table.d/total_corection_distance)
	})

V_final = {.x = 0.0, .y = 0.0}

	foreach(probability,
  	function(id, prob) {
		V_final.x = V_final.x + (1.0/prob)*math.cos(correction_vectors[id].a)
		V_final.y = V_final.y +(1.0/prob)*math.sin(correction_vectors[id].a)
	})
printx = V_final.x * math.cos(pose.orientation.yaw) -math.sin(pose.orientation.yaw)*V_final.y
printy = V_final.y * math.cos(pose.orientation.yaw) +math.sin(pose.orientation.yaw)*V_final.x
	
	debug.rays.add(0,255,0,0.0,0.0,0.1, 5*printx	, 5*printy, 0.1 )

}

#
# Executed once upon resetting
#
function reset() {
	math.rng.setseed(id)
	task = 0
	threshold = {}
	threshold[0] = 500.0
	threshold[1] = 500.0
  # Pick a default task
  # Pick initial thresholds for the tasks
	confidence = {}
  confidence[0] = 0.75
	confidence[1] = 0.10
	confidence[2] = 0.12
	confidence[3] = 0.03
}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

