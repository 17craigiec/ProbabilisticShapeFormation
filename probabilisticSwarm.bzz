PI = 3.14159

map = { .0 = { .1 = { .124.84 = 0.03}, .2 = { .156.87 = -0.74}, .3 = { .103.21 = -1.56}}, .1 = { .0 = { .124.84 = -3.12}, .2 = { .109.16 = -1.65}, .3 = { .162.79 = -2.43}}, .2 = { .0 = { .156.87 = 2.40}, .1 = { .109.16 = 1.49}, .3 = { .114.43 = 3.12}}, .3 = { .0 = { .103.21 = 1.59}, .1 = { .162.79 = 0.71}, .2 = { .114.43 = -0.02}}}

# Subtracts Vector 1 from Vector 0
function subVectors(theta_0, d_0, theta_1, d_1) {
	x_sub = d_0*math.cos(theta_0) - d_1*math.cos(theta_1)
	y_sub = d_0*math.sin(theta_0) - d_1*math.sin(theta_1)
	vect = {}
	vect.x = x_sub
	vect.y = y_sub
	vect.mag = ((x_sub^2) + (y_sub^2))^0.5	
	return vect
}

#
# Find the distance between two angles
#
function delta_angle(angle_1, angle_2) {
	d = angle_1 - angle_2
	return math.abs((d + PI) % (2*PI) - PI)
}

#
# Get the confidence of a given measured angle vs a confidence angle
#
function get_confidence(map_angle, measured_angle){
	delta = delta_angle(map_angle, measured_angle)
	return ((-1/(PI))*delta + 1)
}

# copying tables the right way
function table_copy(t) {
  var t2 = {}
  foreach(t, function(key, value) {
      t2[key] = value
    })
  return t2
}

#
# Function returns a confidence map
#
function get_confidence_map(){
	
	confidence_map = {}
	
	# Evaluate the confidence of the robot for each point in the map normalized from [0, 1]
	foreach(map, function(point, map_edges){

		neighbors_poses = table_copy(neighbors.poses)

		if(size(map_edges) != size(neighbors_poses)){
			confidence_map[point] = 0
		} else {
			c_total = 0

			foreach(map_edges, function(m_neighbor, m_values){ 
				foreach(m_values, function(distance, angle){

					c_max = -1
					c_index = nil

					foreach(neighbors_poses, function(r_neighbor, r_values){

						c = get_confidence(angle, r_values.azimuth - pose.orientation.yaw)

						if (c > c_max) {
							c_max = c
							c_index = r_neighbor
						}

					})

				neighbors_poses[c_index] = nil
				c_total = c_total + c_max

				})
			})

			confidence_map[point] = c_total/size(map_edges)

		}

	})

	return confidence_map

}

function init() {
	reset()
}

#
# Executed once at init time
#
function noinit() {
  reset()
	map_target_vectors = {}

	foreach(map, function(point, list){
		avg_ndistance = 0.0
		avg_nangle = 0.0 
		avg_nangle_sin = 0.0
		avg_nangle_cos = 0.0
		index = 0.0
		foreach(list, function(neighbor, innerTable) {
			index = index + 1.0
			foreach(innerTable, function(distance, angle){
			avg_ndistance = avg_ndistance + distance
			avg_nangle_sin = avg_nangle_sin + math.sin(angle)
			avg_nangle_cos = avg_nangle_cos + math.cos(angle)
			})
		})
		avg_ndistance = avg_ndistance/index
		avg_nangle_sin = avg_nangle_sin/index
		avg_nangle_cos = avg_nangle_cos/index

		avg_nangle = math.atan(avg_nangle_sin, avg_nangle_cos)
		map_target_vectors[point] = {.d = avg_ndistance, .a = avg_nangle}
	}) 

}

function step(){


	#confidence_map = {.0 = 12, .1 = 23}
	confidence_map = get_confidence_map()

	#debug.print(confidence_map)
	
}


#
# Executed for each step
#
function nostep() {
	obst = reduce(proximity,
		function(idx,sensor,sofar) {
			return {
				.x = sofar.x + sensor.value * math.cos(sensor.angle),
				.y = sofar.y + sensor.value * math.sin(sensor.angle)
			}}, { .x = 0.0, .y = 0.0 })

	if (neighbors.count() > 0){
	avg_distance = 0.0
	avg_anlge = 0.0
	avg_angle_sin = 0.0
	avg_angle_cos = 0.0
	i = 0.0
	neighbors.foreach(
  	function(rid, data) {
			 i = i + 1
       avg_distance = avg_distance + data.distance
			 avg_angle_sin = avg_angle_sin + math.sin(data.azimuth)
			 avg_angle_cos = avg_angle_cos + math.cos(data.azimuth)
 		})
	avg_distance = avg_distance/i
	avg_angle = math.atan(avg_angle_sin/i, avg_angle_cos/i)
	
	debug.rays.add(255,0,0,0.0,0.0,0.1, avg_distance*math.cos(avg_angle)/100, avg_distance*math.sin(avg_angle)/100, 0.1 )


	avg_angle = avg_angle + pose.orientation.yaw
	current_vector = {.avg_distance = avg_angle}

	correction_vectors = {}	
	foreach(map_target_vectors,
  	function(rid, innerTable) {
			correction_vectors[rid] = subVectors(avg_angle, avg_distance, innerTable.a, innerTable.d)
		})

	close_est = {}
	close_est.a = 0
	close_est.d = 9999
	close_est.n = 0
	foreach(correction_vectors,
  	function(id, table) {
		if(close_est.d > table.d){
			close_est.a = table.a
			close_est.d = table.d
			close_est.n = id
		}
	})
  
	#debug.rays.add(0,255,0, 0.0,0.0,0.1, close_est.d*cos(close_est.a), close_est.d*sin(close_est.a), 0.1 )
	}
	else
	{
		diffusing(obst.x, obst.y)
	}
}

function diffusing(x, y)
{
	if((x < 0.0001) and (y < 0.0001))
	{
		gotoc(7, 0) 
	}else{
		angle = math.atan(x,y)
		if((angle > 0) and (3.14 > angle))
		{
			set_wheels(-7.0, 7.0)
		}	
		else
		{		 	
			set_wheels(7.0, -7.0)
		}
	}
}

function move(x, y){
	offset = pose.orientation.yaw
	x2 = math.cos(offset)*x - math.sin(offset)*y
	y2 = math.sin(offset)*x + math.cos(offset)*y
	gotoc(x2,y2)
}


#
# Executed once upon resetting
#
function reset() {
	math.rng.setseed(id)
	threshold = {}
	threshold[0] = 500.0
	threshold[1] = 500.0
  # Pick a default task
  # Pick initial thresholds for the tasks
	confidence = {}
  confidence[0] = 0.75
	confidence[1] = 0.10
	confidence[2] = 0.12
	confidence[3] = 0.03
}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

