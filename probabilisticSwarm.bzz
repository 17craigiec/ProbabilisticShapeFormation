PI = 3.14159

map = { .0 = { .1 = { .100.54 = 1.12}, .2 = { .83.26 = -0.04}}, .1 = { .0 = { .100.54 = -2.02}, .2 = { .101.48 = -1.17}}, .2 = { .0 = { .83.26 = 3.10}, .1 = { .101.48 = 1.97}}}



# Subtracts Vector 1 from Vector 0
function subVectors(theta_0, d_0, theta_1, d_1) {
	x_sub = d_0*math.cos(theta_0) - d_1*math.cos(theta_1)
	y_sub = d_0*math.sin(theta_0) - d_1*math.sin(theta_1)
	vect = {}
	vect.x = x_sub
	vect.y = y_sub
	vect.mag = ((x_sub^2) + (y_sub^2))^0.5	
	return vect
}

function drawGlobalLine(r,g,b, x,y) {
	cur_heading = pose.orientation.yaw
	x_print = x*math.cos(-cur_heading) - y*math.sin(-cur_heading)
	y_print = x*math.sin(-cur_heading) + y*math.cos(-cur_heading)
	debug.rays.add(r,g,b,0.0,0.0,0.1, x_print, y_print, 0.1 )
}

#
# Find the distance between two angles
#
function delta_angle(angle_1, angle_2) {
	d = angle_1 - angle_2
	return math.abs((d + PI) % (2*PI) - PI)
}

#
# Get the confidence of a given measured angle vs a confidence angle
#
ALPHA = 10 # Steepness
BETA = PI/4 # 50% value: range from 0 to PI

function get_confidence(map_angle, measured_angle){
	delta = delta_angle(map_angle, measured_angle)
	confidence = 1/(1 + math.exp(ALPHA*(delta-BETA)))
	log("Delta: ", delta, " confidence: ", confidence)

	return confidence
}

# copying tables the right way
function table_copy(t) {
  var t2 = {}
  foreach(t, function(key, value) {
      t2[key] = value
    })
  return t2
}

function get_best_map(list_of_maps){

	best_map = nil
	best_sum = 0

	foreach(list_of_maps, function(index, map){

		c_sum = 0

		foreach(map, function(point, confidence){
				
			c_sum = c_sum + confidence

		})

		if (c_sum > best_sum){
			
			best_map = index
			best_sum = c_sum

		}

	})

	return list_of_maps[best_map]

}

# Returns nil if no confidence in the list contains the target robot, but returns the list if there is the target robot
function c_list_contains_robot(c_list, robot){

	foreach(c_list, function(rid, c_val){
		if(rid == robot) {
			return c_list
		}
	})

}

# Find the max confidence arrangement given the list of confidences, map_node is the node on the map the confidence is comparing to, r_c is a table containing the neighbors robot id and the confidence in the specific map node
function find_max_confidence(list_of_confidence){

	possible_c = {}
	index = 0

	foreach(list_of_confidence, function(map_node, r_c){

		foreach(r_c, function(rid, c_val){

			#if(c_list_contains_robot())

		})

	})

}

#
# Function returns a confidence map
#
function get_confidence_map(){

	
	neighbors_poses = neighbors.poses

	# Evaluate the confidence of the robot for each point in the map normalized from [0, 1]
	foreach(map, function(point, map_edges){

		confidence_map = {}

		if(size(neighbors_poses) == 0){
			confidence_map[point] = 0
		} else {
			c_total = 0

			log("Point: ", point)
			p_c = {} # Possible confidences {.Point = {.Neighbor_1 = c1, .Neighbor_2 = c2}}

			foreach(map_edges, function(m_neighbor, m_values){ 
				foreach(m_values, function(distance, angle){

					log("Map Neighbor: ", m_neighbor)

					r_c = {} # List of confidences per neighbor robot

					foreach(neighbors_poses, function(r_neighbor, r_values){

						log("Robot Neighbor: ", r_neighbor)

						c = get_confidence(angle, r_values.azimuth + pose.orientation.yaw)

						r_c[r_neighbor] = c

					})

					p_c[m_neighbor] = r_c

					#c_total = c_total + c

				})
			})

			c_max = find_max_confidence(p_c)
			confidence_map[point] = c_max/size(map_edges)

		}

	})

	# Normalize total probabilities from 0 to 1
	total = 0
	foreach(confidence_map, function(point, value){
		total = total + value
	})

	if (total > 0){
		foreach(confidence_map, function(point, value){
			confidence_map[point] = value/total
		})
	}

	return confidence_map

}

function init() {
  reset()
	map_target_vectors = {}

	foreach(map, function(point, list){
		avg_ndistance = 0.0
		avg_nangle = 0.0 
		avg_nangle_sin = 0.0
		avg_nangle_cos = 0.0
		index = 0.0
		foreach(list, function(neighbor, innerTable) {
			index = index + 1.0
			foreach(innerTable, function(distance, angle){
			avg_ndistance = avg_ndistance + distance
			avg_nangle_sin = avg_nangle_sin + math.sin(angle)
			avg_nangle_cos = avg_nangle_cos + math.cos(angle)
			})
		})
		avg_ndistance = avg_ndistance/index
		avg_nangle_sin = avg_nangle_sin/index
		avg_nangle_cos = avg_nangle_cos/index

		avg_nangle = math.atan(avg_nangle_sin, avg_nangle_cos)
		map_target_vectors[point] = {.d = avg_ndistance, .a = avg_nangle}
	}) 
}

function step() {

	log("Robot: ", id)

	confidence_map = get_confidence_map()
	cur_heading = pose.orientation.yaw
	obst = reduce(proximity,
		function(idx,sensor,sofar) {
			return {
				.x = sofar.x + sensor.value * math.cos(sensor.angle),
				.y = sofar.y + sensor.value * math.sin(sensor.angle)
			}}, { .x = 0.0, .y = 0.0 })

	if (neighbors.count() > 0){
	avg_distance = 0.0
	avg_angle = 0.0
	avg_angle_sin = 0.0
	avg_angle_cos = 0.0
	i = 0.0
	neighbors.foreach(
  	function(rid, data) {
			 i = i + 1
       avg_distance = avg_distance + data.distance
			 avg_angle_sin = avg_angle_sin + math.sin(data.azimuth)
			 avg_angle_cos = avg_angle_cos + math.cos(data.azimuth)
 		})
	avg_distance = avg_distance/i
	avg_angle = math.atan(avg_angle_sin/i, avg_angle_cos/i)
	tmp_cur_x = avg_distance*math.cos(avg_angle)
	tmp_cur_y = avg_distance*math.sin(avg_angle)

	cur_avg_vector = {}
	cur_avg_vector.x = tmp_cur_x*math.cos(cur_heading) - tmp_cur_y*math.sin(cur_heading)
	cur_avg_vector.y = tmp_cur_x*math.sin(cur_heading) + tmp_cur_y*math.cos(cur_heading)
	cur_avg_vector.mag = ((cur_avg_vector.x)^2+(cur_avg_vector.y)^2)^0.5
	cur_avg_vector.theta = math.atan(cur_avg_vector.y,cur_avg_vector.x)

	debug.print(cur_heading*180/PI)
	drawGlobalLine(205,50,0, cur_avg_vector.x/100,cur_avg_vector.y/100)

	correction_vectors = {}	
	foreach(map_target_vectors,
  	function(rid, innerTable) {
			correction_vectors[rid] = subVectors(cur_avg_vector.theta, cur_avg_vector.mag, innerTable.a, innerTable.d)
		})
	
	# confidence vector
	confidence_vector = {}
	confidence_vector.mag = 0
	confidence_vector.x = 0
	confidence_vector.y = 0

	hasConfidence = 0

	# replace with confidence sum
	foreach(correction_vectors,
  	function(id, table) {
		if (confidence_map[id] != 0)
		{
			hasConfidence = 1
		}
		confidence_vector.mag = confidence_vector.mag +  confidence_map[id]*table.mag
		confidence_vector.x = confidence_vector.x + confidence_map[id]*table.x
		confidence_vector.y = confidence_vector.y + confidence_map[id]*table.y

	})

	#move(close_est.x,close_est.y)  
		drawGlobalLine(0,205,50, confidence_vector.x/100, confidence_vector.y/100)
		if (hasConfidence)
			move(confidence_vector.x, confidence_vector.y, 0)
		else
			move(obst.x, obst.y, 1)
	}
	else
	{
		move(obst.x, obst.y, 1)
	}
}


function move(x, y, diffuse){
	if(diffuse){
		if((x < 0.0001) and (y < 0.0001))
		{
			gotoc(7, 0) 
		}else{
			angle = math.atan(x,y)
		if((angle > 0) and (3.14 > angle))
		{
			set_wheels(-7.0, 7.0)
		}	
		else
		{		 	
			set_wheels(7.0, -7.0)
		}
		}
	}
	else{
		desired_angle = math.atan(y, x)
		error = pose.orientation.yaw - desired_angle
		error_threshold = 0.04
		if(math.abs(error) < error_threshold)
		{
			set_wheels(10.0,10.0)
		}
		else if (error > 0){
			set_wheels(5.0,-5.0)
		}
		else{
			set_wheels(-5.0,5.0)
		} 
		debug.print("Err:", error, "   da:", desired_angle)
	}
}


#
# Executed once upon resetting
#
function reset() {

}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

